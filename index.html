<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>File Upload</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 20px; }
    #drop-area {
      border: 2px dashed #ccc;
      border-radius: 10px;
      width: 80%;
      height: 30vh;
      margin: 5px auto;
      padding: 2px;
      background: #f9f9f9;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #drop-area.hover { background: #e9e9e9; }
    #clearButton {
      margin: 20px auto 20px auto;
      display: block;
      align-items: center;
    }
    #fieldsetSection {
      border: 1px solid #4a4a4a;
      border-radius: 8px;
      width: 80%;
      margin: 5px auto;
      align-self: center;
      display: none;
    }
    #success, #failure, #progress, #status, #skipped {
      margin: 0px auto;
      max-height: 200px;
      overflow-y: auto;
      border-radius: 4px;
      display: none;
    }
    #success, #failure, #progress, #skipped {
      text-align: left;
    }
    #status { color: blue; text-align: center; }
    #progress { color: orange; }
    #success { color: green; }
    #failure { color: red; }
    #skipped { color: DodgerBlue; }
    #file-list { text-align: left; }
    table {
      width: 80%;
      margin: 10px auto;
      border-collapse: collapse;
      border: 1px solid #ccc;
    }
    th, td {
      border: 1px solid #aaa;
      padding: 8px 12px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    tr:nth-child(even) {
      background-color: #f9f9f9;
    }
    tr:nth-child(odd) {
      background-color: #ffffff;
    }
    td:nth-child(even), th:nth-child(even) {
      text-align: right;
    }
    td:nth-child(odd), th:nth-child(odd) {
      text-align: left;
    }
    tr:hover {
      background-color: #e6f7ff;
    }
  </style>
  <link type="image/png" sizes="16x16" rel="icon" href="favicon.png">
</head>
<body>

<h2>File Upload</h2>
<div id="drop-area">
  Drop files or folders here
</div>

<button id="clearButton" onclick="clearReport()">Clear Report / New Upload</button>
<fieldset id="fieldsetSection"> 
  <legend>Status</legend>
  <div id="status" ></div>
</fieldset>
<fieldset id="fieldsetSection"> 
  <legend>Progress</legend>
  <div id="progress" ></div>
</fieldset>
<fieldset id="fieldsetSection"> 
  <legend>Success</legend>
  <div id="success" ></div>
</fieldset>
<fieldset id="fieldsetSection"> 
  <legend>Already Present</legend>
  <div id="skipped" ></div>
</fieldset>
<fieldset id="fieldsetSection"> 
  <legend>Failure</legend>
  <div id="failure" ></div>
</fieldset>
<div id="file-list" ></div>

<script>
  // Check if browser supports folder upload
  const supportsFolderUpload = 'webkitGetAsEntry' in DataTransferItem.prototype;
  if (!supportsFolderUpload) {
    console.warn("Folder upload not supported in this browser. Single file upload will work.");
  }

  let totalFiles = 0;
  let completedFiles = 0;
  let failedFiles = 0;
  let totalBytes = 0;
  let uploadedBytes = 0;

  const MAX_CONCURRENT_UPLOADS = 5;
  const uploadQueue = [];
  let activeUploads = 0;

  const successLogs = [];
  const failureLogs = [];
  const skippedLogs = [];
  const fileProgressElements = {};

  const dropArea = document.getElementById("drop-area");
  window.addEventListener("dragover", e => e.preventDefault(), false);
  window.addEventListener("drop", e => e.preventDefault(), false);
  window.addEventListener('DOMContentLoaded', () => {
    listFiles();
  });

  dropArea.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropArea.classList.add("hover");
  });

  dropArea.addEventListener("dragleave", () => {
    dropArea.classList.remove("hover");
  });

  dropArea.addEventListener("drop", (e) => {
    e.preventDefault();
    dropArea.classList.remove("hover");

    const items = e.dataTransfer.items;
    const files = e.dataTransfer.files;
    
    clearReport();
    dropArea.style.display = "none";
    ["status", "progress"].forEach(id => {
      const el = document.getElementById(id);
      const fs = el.closest("fieldset");
      el.style.display = "block";
      if (fs) fs.style.display = "block";
    });

    // Try Chrome folder API first
    if (items && items.length > 0 && items[0].webkitGetAsEntry) {
      const entries = [];
      for (const item of items) {
        const entry = item.webkitGetAsEntry?.();
        if (entry) entries.push(entry);
      }
      
      countFilesAndBytes(entries).then(({ count, size }) => {
        totalFiles = count;
        totalBytes = size;
        for (const entry of entries) {
          traverseFileTree(entry);
        }
      });
    } else if (files && files.length > 0) {
      // Fallback for Firefox/Safari - just files, no folder structure
      totalFiles = files.length;
      totalBytes = 0;
      for (const file of files) {
        totalBytes += file.size;
        uploadQueue.push({ file, path: file.name });
      }
      processQueue();
    }
    
    listFiles();
  });

  function countFilesAndBytes(entries) {
    const promises = entries.map(entry => {
      return new Promise(resolve => {
        if (entry.isFile) {
          entry.file(file => resolve({ count: 1, size: file.size }));
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          reader.readEntries(subEntries => {
            countFilesAndBytes(subEntries).then(resolve);
          });
        } else {
          resolve({ count: 0, size: 0 });
        }
      });
    });

    return Promise.all(promises).then(results => {
      return results.reduce((acc, r) => ({
        count: acc.count + r.count,
        size: acc.size + r.size
      }), { count: 0, size: 0 });
    });
  }

  function traverseFileTree(item, path = "") {
    if (item.isFile) {
      item.file(file => {
        uploadQueue.push({ file, path: path + file.name });
        processQueue();
      });
    } else if (item.isDirectory) {
      if (item.createReader) {
        const dirReader = item.createReader();
        dirReader.readEntries(entries => {
          for (const entry of entries) {
            traverseFileTree(entry, path + item.name + "/");
          }
        });
      } else {
        console.warn("Directory upload not supported in this browser");
      }
    }
  }

  function processQueue() {
    while (activeUploads < MAX_CONCURRENT_UPLOADS && uploadQueue.length > 0) {
      const { file, path } = uploadQueue.shift();
      activeUploads++;
      uploadFile(file, path);
    }
  }

  function formatBytes(bytes) {
    if (bytes === 0) return '0 bytes';
    const k = 1024;
    const sizes = ['bytes', 'KB', 'MB', 'GB', 'TB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    const num = bytes / Math.pow(k, i);
    return `${num.toFixed(i === 0 ? 0 : 2)} ${sizes[i]}`;
  }

  function updateOverallStatus() {
    const percent = totalBytes > 0 ? ((uploadedBytes / totalBytes) * 100).toFixed(2) : 0;
    document.getElementById("status").textContent =
      `Total: ${completedFiles}/${totalFiles} (${percent}%) | Uploaded: ${formatBytes(uploadedBytes)} / ${formatBytes(totalBytes)} | Failed: ${failedFiles}`;
  }

  function uploadFile(file, relativePath) {
    const progressContainer = document.getElementById("progress");
    const progressLine = document.createElement("div");
    const fileSizeMB = (file.size / (1024 * 1024)).toFixed(2);
    progressLine.textContent = `${relativePath} (${fileSizeMB} MB): 0%`;
    progressContainer.appendChild(progressLine);

    fileProgressElements[relativePath] = {
      element: progressLine,
      lastLoaded: 0
    };

    const formData = new FormData();
    formData.append("file", file, relativePath);
    formData.append("path", relativePath);

    const xhr = new XMLHttpRequest();
    xhr.open("POST", "/");

    xhr.upload.onprogress = (e) => {
      if (e.lengthComputable) {
        const percent = Math.round((e.loaded / e.total) * 100);
        const fileState = fileProgressElements[relativePath];

        fileState.element.textContent = `${relativePath}: ${percent}% (${formatBytes(e.loaded)} / ${formatBytes(e.total)})`;
        updateOverallStatus();
      }
    };

    xhr.onload = () => {
      completedFiles++;
      activeUploads--;
      uploadedBytes += file.size;
      
      if (xhr.status >= 200 && xhr.status < 300) {
        try {
          const response = JSON.parse(xhr.responseText);
          if (response.status === 'skipped') {
            skippedLogs.push(relativePath);
            updateDisplayLogs("skipped", skippedLogs);
          } else if (response.status === 'success') {
            successLogs.push(relativePath);
            updateDisplayLogs("success", successLogs);
          } else {
            // Unknown status
            failedFiles++;
            failureLogs.push(`${relativePath} → Unknown status: ${response.status}`);
            updateDisplayLogs("failure", failureLogs);
          }
        } catch (e) {
          console.error("Failed to parse JSON response:", e, xhr.responseText);
          failedFiles++;
          failureLogs.push(`${relativePath} → Parse error`);
          updateDisplayLogs("failure", failureLogs);
        }
      } else {
        failedFiles++;
        let errorMsg = `${relativePath} → HTTP ${xhr.status}`;
        try {
          const errorResponse = JSON.parse(xhr.responseText);
          if (errorResponse.error) {
            errorMsg += `: ${errorResponse.error}`;
          }
        } catch (e) {
          // Non-JSON error response
        }
        failureLogs.push(errorMsg);
        updateDisplayLogs("failure", failureLogs);
      }

      document.getElementById("progress").removeChild(fileProgressElements[relativePath].element);
      delete fileProgressElements[relativePath];
      updateOverallStatus();

      if (completedFiles === totalFiles) {
        const dropArea = document.getElementById("drop-area");
        dropArea.style.display = "flex";
        const pl = document.getElementById("progress");
        pl.style.display = "none";
        const fs = pl.closest("fieldset");
        if (fs) fs.style.display = "none";
        listFiles();
      } else {
        processQueue();
      }
    };

    xhr.onerror = () => {
      completedFiles++;
      activeUploads--;
      failedFiles++;
      failureLogs.push(`${relativePath} → Upload failed`);
      updateDisplayLogs("failure", failureLogs);
      document.getElementById("progress").removeChild(fileProgressElements[relativePath].element);
      delete fileProgressElements[relativePath];
      updateOverallStatus();
      processQueue();
    };

    xhr.send(formData);
  }

  function updateDisplayLogs(containerId, logArray) {
    const container = document.getElementById(containerId);
    const fieldset = container.closest("fieldset");
    container.innerHTML = "";
    if (logArray.length === 0) {
      container.style.display = "none";
      if (fieldset) fieldset.style.display = "none";
      return;
    }
    container.style.display = "block";
    if (fieldset) fieldset.style.display = "block";
    for (const line of logArray) {
      const div = document.createElement("div");
      div.textContent = line;
      container.appendChild(div);
    }
    container.scrollTop = container.scrollHeight;
  }

  function listFiles() {
    const xhr = new XMLHttpRequest();
    xhr.open('GET', '/list', true);

    xhr.onload = function () {
      if (xhr.status >= 200 && xhr.status < 300) {
        console.log('file: ', xhr.responseText);
        const items = JSON.parse(xhr.responseText);
        const container = document.getElementById('file-list');
        container.innerHTML = '';

        // Only show table if there are files
        if (items.length > 0) {
          const table = document.createElement('table');
          const headerRow = document.createElement('tr');
          headerRow.innerHTML = `
            <th>File/Directory</th>
            <th>Size</th>
          `;
          table.appendChild(headerRow);

          items.forEach(item => {
            // const div = document.createElement('div');
            const isDir = item.path.endsWith("/");
            // print(`Listing: ${item.path} (isDir: ${isDir})`);
            // div.textContent = `${item.path}${isDir ? '' : ' — ' + formatBytes(item.size)}`;
            // container.appendChild(div);
            const row = document.createElement('tr');
            row.innerHTML = `
              <td>${item.path}</td>
              <td>${isDir ? "" : formatBytes(item.size)}</td>
            `;
            table.appendChild(row);
          });
          container.appendChild(table);
        }
      } else {
        alert('Failed to fetch file list: HTTP ' + xhr.status);
      }
    };

    xhr.onerror = function () {
      alert('Failed to fetch file list: Network error');
    };

    xhr.send();
  }


  function clearReport() {
    completedFiles = 0;
    failedFiles = 0;
    totalFiles = 0;
    uploadedBytes = 0;
    totalBytes = 0;
    activeUploads = 0;
    uploadQueue.length = 0;
    successLogs.length = 0;
    failureLogs.length = 0;
    skippedLogs.length = 0;
    Object.keys(fileProgressElements).forEach(key => delete fileProgressElements[key]);

    ["status", "progress", "success", "failure", "skipped"].forEach(id => {
      const el = document.getElementById(id);
      el.textContent = "";
      el.innerHTML = "";
      el.style.display = "none";
      const fs = el.closest("fieldset");
      if (fs) fs.style.display = "none";
    });
  }
</script>

</body>
</html>
